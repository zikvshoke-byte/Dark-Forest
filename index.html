<!-- ... (весь твой CSS остается без изменений) ... -->

<!-- Добавляем загрузчик GLTFLoader после основной библиотеки Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
/** ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ **/
// ... (твои переменные остаются) ...
let monster; // Теперь это будет загруженная модель

// ... (функции звука остаются) ...

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000105);
    scene.fog = new THREE.FogExp2(0x000105, 0.05);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1);
    document.body.appendChild(renderer.domElement);

    // СВЕТ (Фонарик)
    flashlight = new THREE.SpotLight(0xffffff, 20, 200, Math.PI/4.5, 0.4, 0.5);
    flashlight.position.set(0, 0, 0.1); flashlight.target = new THREE.Object3D();
    camera.add(flashlight); camera.add(flashlight.target); flashlight.target.position.set(0, 0, -1);

    nearLight = new THREE.PointLight(0xffffff, 2, 12);
    camera.add(nearLight);
    scene.add(camera);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), new THREE.MeshPhongMaterial({ color: 0x050805 }));
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // ДЕРЕВЬЯ
    const treeGeo = new THREE.CylinderGeometry(0.5, 0.7, 14, 6);
    const treeMat = new THREE.MeshLambertMaterial({ color: 0x0f0a05 });
    const instancedTrees = new THREE.InstancedMesh(treeGeo, treeMat, 180);
    const dummy = new THREE.Object3D();
    for(let i=0; i<180; i++) {
        let x = Math.random()*280-140, z = Math.random()*280-140;
        dummy.position.set(x, 7, z); dummy.updateMatrix();
        instancedTrees.setMatrixAt(i, dummy.matrix);
        treePositions.push({x: x, z: z});
        if(i < 10) {
            let note = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.6), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 3 }));
            note.position.set(x, 1.8, z + 0.65); note.userData = { id: i };
            scene.add(note); notes.push(note);
            let nLight = new THREE.PointLight(0xffffff, 3, 10);
            nLight.position.set(x, 1.8, z + 0.8); scene.add(nLight);
        }
    }
    scene.add(instancedTrees);

    // Загружаем модель монстра вместо создания ее из кубиков
    loadMonster();

    clock = new THREE.Clock();
    setupControls();
    animate();
}

// НОВАЯ ФУНКЦИЯ ЗАГРУЗКИ МОДЕЛИ
function loadMonster() {
    const loader = new THREE.GLTFLoader();
    
    // Путь к файлу. Файл должен лежать в той же папке, что и index.html
    loader.load('monster.glb', function (gltf) {
        monster = gltf.scene;
        
        // Масштабируем монстра (отрегулируй цифры, если он слишком большой или маленький)
        monster.scale.set(1.5, 1.5, 1.5); 
        
        // Проходим по всем частям модели, чтобы включить тени
        monster.traverse(function (child) {
            if (child.isMesh) {
                child.castShadow = true;
                // Если модель слишком темная, можно изменить материал:
                // child.material.emissive = new THREE.Color(0x050000); 
            }
        });

        monster.visible = false;
        scene.add(monster);
        console.log("Монстр успешно загружен!");
        
    }, undefined, function (error) {
        console.error("Ошибка при загрузке монстра! Проверь, лежит ли файл monster.glb в папке с игрой.", error);
    });
}

// ... (setupControls остается без изменений) ...

function updateMonster(dt) {
    if (!monster || stats.notes < 3) return; // Ждем загрузки модели и 3 записок
    
    monster.visible = true;
    const distSq = camera.position.distanceToSquared(monster.position);
    let dist = Math.sqrt(distSq);

    sndBreath.volume = Math.max(0, 1 - (dist / 45)) * masterGain.gain.value;
    if(sndBreath.paused) sndBreath.play().catch(()=>{});

    if(monsterState === 'idle') monsterState = 'stalk';
    
    if(monsterState === 'stalk') {
        if(Math.random() < 0.007) {
            let a = camera.rotation.y + Math.PI + (Math.random()-0.5)*2;
            let spawnDist = 18 + Math.random() * 8;
            monster.position.set(camera.position.x + Math.sin(a)*spawnDist, 0, camera.position.z + Math.cos(a)*spawnDist);
            monster.lookAt(camera.position.x, 0, camera.position.z);
        }
    }

    if(stats.notes >= 5 && monsterState === 'stalk') { monsterState = 'attack5'; monsterTime = 30; document.getElementById('blood').style.display = 'block'; }
    if(stats.notes >= 9 && monsterState !== 'attack9') { monsterState = 'attack9'; monsterTime = 60; document.getElementById('blood').style.display = 'block'; }
    
    if(monsterState.includes('attack')) {
        monsterTime -= dt;
        let dir = new THREE.Vector3().subVectors(camera.position, monster.position);
        dir.y = 0; dir.normalize();
        monster.position.add(dir.multiplyScalar(0.16));
        monster.lookAt(camera.position.x, 0, camera.position.z);
        if(distSq < 4.0) triggerScreamer("death.png", true);
        if(monsterTime <= 0) { monsterState = 'stalk'; document.getElementById('blood').style.display = 'none'; }
    }
    
    // Коллизия с игроком (если подошел слишком близко)
    if(distSq < 3.5) triggerScreamer("death.png", true);
}

// ... (animate и остальной код остаются без изменений) ...
</script>
<!-- ... -->