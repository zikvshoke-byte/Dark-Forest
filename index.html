<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>THE FOREST: STALKER</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; touch-action: none; }
        canvas { display: block; }

        /* МЕНЮ */
        #menu {
            position: fixed; inset: 0; background: radial-gradient(circle, #1a0000 0%, #000 100%);
            color: #f00; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        #menu h1 { font-size: 8vh; text-shadow: 0 0 20px #f00; margin: 0; letter-spacing: 15px; font-weight: 100; }
        .slider-group { margin: 15px; text-align: center; width: 75%; max-width: 400px; color: #fff; }
        input[type=range] { width: 100%; height: 35px; accent-color: #f00; }
        #start-btn { 
            padding: 15px 60px; font-size: 24px; background: #300; color: #fff; border: 2px solid #f00; 
            border-radius: 5px; cursor: pointer; margin-top: 25px; box-shadow: 0 0 15px #f00;
        }

        /* HUD */
        #hud { position: absolute; top: 20px; left: 20px; color: white; display: none; z-index: 50; pointer-events: none; }
        .bar-container { width: 150px; height: 10px; background: #222; border: 1px solid #fff; margin-top: 5px; margin-bottom: 10px; }
        #stamina-fill { width: 100%; height: 100%; background: #0f0; }
        #battery-fill { width: 100%; height: 100%; background: #0cf; }
        #notes-text { font-size: 20px; font-weight: bold; text-shadow: 2px 2px #000; }

        /* УПРАВЛЕНИЕ */
        #joy-zone { 
            position: absolute; bottom: 40px; left: 40px; width: 130px; height: 130px; 
            background: rgba(255,255,255,0.05); border-radius: 50%; border: 1px solid rgba(255,255,255,0.1); 
        }
        #joy-stick { 
            position: absolute; width: 60px; height: 60px; background: rgba(255,255,255,0.3); 
            border-radius: 50%; top: 35px; left: 35px; pointer-events: none;
        }
        #sprint-btn { 
            position: absolute; bottom: 50px; right: 40px; width: 85px; height: 85px; 
            background: rgba(150,0,0,0.2); border: 2px solid #fff; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;
        }
        #flashlight-btn { 
            position: absolute; bottom: 145px; right: 40px; width: 65px; height: 65px; 
            background: rgba(0,200,255,0.2); border: 2px solid #0cf; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;
        }

        #screamer { position: fixed; inset: 0; background-color: black; background-position: center; background-size: cover; display: none; z-index: 2000; }
        #blood { position: fixed; inset: 0; background: rgba(180, 0, 0, 0.3); display: none; pointer-events: none; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 4px; height: 4px; background: #fff; border-radius: 50%; transform: translate(-50%, -50%); opacity: 0.5; }
    </style>
</head>
<body>

<div id="menu">
    <h1>ЛЕС</h1>
    <div class="slider-group">
        <label>ЧУВСТВИТЕЛЬНОСТЬ</label><br>
        <input type="range" id="sens" min="10" max="150" value="70">
    </div>
    <div class="slider-group">
        <label>ГРОМКОСТЬ</label><br>
        <input type="range" id="vol" min="0" max="100" value="70">
    </div>
    <button id="start-btn">ИГРАТЬ</button>
</div>

<div id="hud">
    <div id="notes-text">ЗАПИСКИ: 0 / 10</div>
    <div style="font-size: 11px; margin-top:5px;">ВЫНОСЛИВОСТЬ</div>
    <div class="bar-container"><div id="stamina-fill"></div></div>
    <div style="font-size: 11px;">БАТАРЕЯ (60с)</div>
    <div class="bar-container"><div id="battery-fill"></div></div>
</div>

<div id="blood"></div>
<div id="screamer"></div>
<div id="crosshair"></div>
<div id="joy-zone"><div id="joy-stick"></div></div>
<div id="sprint-btn">БЕГ</div>
<div id="flashlight-btn">СВЕТ</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/** ДВИЖОК **/
let scene, camera, renderer, clock, flashlight, nearLight;
let moveDir = { f: 0, s: 0 };
let lookData = { id: null, lastX: 0, lastY: 0 };
let joyData = { id: null, centerX: 0, centerY: 0 };
let stats = { notes: 0, stamina: 100, isSprinting: false, sens: 0.002, battery: 100, lightOn: true };
let monster, monsterState = 'idle', monsterTime = 0;
let treePositions = [], notes = [], randomScreamerIndices = [];

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let masterGain = audioCtx.createGain();
masterGain.connect(audioCtx.destination);
const sndBreath = new Audio('breath.mp3'); sndBreath.loop = true;
const sndNoteScream = new Audio('scream_note.mp3');
const sndDeathScream = new Audio('scream_death.mp3');

function playClick() {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(stats.lightOn ? 800 : 400, audioCtx.currentTime);
    g.gain.setValueAtTime(0.1, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
    o.connect(g); g.connect(masterGain); o.start(); o.stop(audioCtx.currentTime + 0.1);
}
function playPaper() {
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
    const d = buf.getChannelData(0); for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
    const s = audioCtx.createBufferSource(); s.buffer = buf;
    const f = audioCtx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 1500;
    const g = audioCtx.createGain(); g.gain.setValueAtTime(0.1, audioCtx.currentTime);
    s.connect(f); f.connect(g); g.connect(masterGain); s.start();
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.045);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';
    
    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1);
    document.body.appendChild(renderer.domElement);

    flashlight = new THREE.SpotLight(0xffffff, 25, 200, Math.PI/5, 0.4, 1.0);
    flashlight.position.set(0, 0, 0.1);
    flashlight.target = new THREE.Object3D();
    camera.add(flashlight); camera.add(flashlight.target);
    flashlight.target.position.set(0, 0, -1);

    nearLight = new THREE.PointLight(0xffffff, 1.5, 12);
    camera.add(nearLight);
    scene.add(camera);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), new THREE.MeshPhongMaterial({ color: 0x050505 }));
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    const treeGeo = new THREE.CylinderGeometry(0.5, 0.7, 14, 6);
    const treeMat = new THREE.MeshPhongMaterial({ color: 0x0a0a0a });
    const instancedTrees = new THREE.InstancedMesh(treeGeo, treeMat, 220);
    const dummy = new THREE.Object3D();
    for(let i=0; i<220; i++) {
        let x = Math.random()*350-175, z = Math.random()*350-175;
        dummy.position.set(x, 7, z); dummy.updateMatrix();
        instancedTrees.setMatrixAt(i, dummy.matrix);
        treePositions.push({x: x, z: z});
        if(i < 10) {
            let note = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.6), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2.5 }));
            note.position.set(x, 1.8, z + 0.75); note.userData = { id: i };
            scene.add(note); notes.push(note);
            let nLight = new THREE.PointLight(0xffffff, 3, 10);
            nLight.position.set(x, 1.8, z + 0.8); scene.add(nLight);
        }
    }
    scene.add(instancedTrees);

    while(randomScreamerIndices.length < 3) {
        let r = Math.floor(Math.random()*10);
        if(!randomScreamerIndices.includes(r)) randomScreamerIndices.push(r);
    }

    createAbomination();
    clock = new THREE.Clock();
    setupControls();
    animate();
}

function createAbomination() {
    monster = new THREE.Group();
    const skinMat = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a, metalness: 0.8, roughness: 0.1, emissive: 0x0a0000 
    });

    // Позвоночник
    for(let i=0; i<9; i++) {
        const spine = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.45, 0.4), skinMat);
        spine.position.set(0, 0.6 + i*0.5, -0.2 - i*0.1);
        spine.rotation.x = 0.45;
        monster.add(spine);
    }

    // Торс и Ребра
    const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1.0, 3.5, 6), skinMat);
    torso.position.y = 2.5; torso.rotation.x = 0.4;
    monster.add(torso);

    for(let i=0; i<4; i++) {
        const rib = new THREE.Mesh(new THREE.TorusGeometry(0.9, 0.08, 6, 12), skinMat);
        rib.position.set(0, 2.0 + i*0.5, 0.2); rib.rotation.x = Math.PI/2 + 0.3;
        monster.add(rib);
    }

    // Мощные Лапы
    for(let side of [-1, 1]) {
        const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.35, 2.5), skinMat);
        th thigh.position.set(0.7 * side, 1.2, -0.4); thigh.rotation.x = -0.4;
        monster.add(thigh);

        const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 3), skinMat);
        shin.position.set(0.7 * side, 0, 0.1);
        monster.add(shin);

        const upperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.2, 3.5), skinMat);
        upperArm.position.set(1.2 * side, 3.2, 0.6); upperArm.rotation.z = side * 0.4; upperArm.rotation.x = -0.7;
        monster.add(upperArm);
        
        const forearm = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 3.5), skinMat);
        forearm.position.set(1.6 * side, 1.2, 1.6); forearm.rotation.x = 0.4;
        monster.add(forearm);
    }

    // Голова
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 0.8), skinMat);
    head.position.set(0, 4.6, 1.3); head.rotation.x = 0.2;
    monster.add(head);

    const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.7), skinMat);
    jaw.position.set(0, 4.1, 1.5); jaw.rotation.x = 0.5;
    monster.add(jaw);

    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const eL = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8), eyeMat); eL.position.set(-0.2, 4.8, 1.7);
    const eR = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8), eyeMat); eR.position.set(0.2, 4.8, 1.7);
    monster.add(eL, eR);

    let eyeLight = new THREE.PointLight(0xff0000, 4, 8);
    eyeLight.position.set(0, 4.8, 1.9); monster.add(eyeLight);

    monster.position.y = 0;
    scene.add(monster);
    monster.visible = false;
}

function setupControls() {
    const joyZone = document.getElementById('joy-zone');
    const stick = document.getElementById('joy-stick');
    const flashBtn = document.getElementById('flashlight-btn');

    window.ontouchstart = e => {
        for(let t of e.changedTouches) {
            const rect = joyZone.getBoundingClientRect();
            if(t.clientX > rect.left && t.clientX < rect.right && t.clientY > rect.top && t.clientY < rect.bottom) {
                joyData.id = t.identifier; joyData.centerX = rect.left + rect.width/2; joyData.centerY = rect.top + rect.height/2;
            } else if(t.clientX > window.innerWidth/2) {
                lookData.id = t.identifier; lookData.lastX = t.clientX; lookData.lastY = t.clientY;
                interact(t.clientX, t.clientY);
            }
        }
    };

    window.ontouchmove = e => {
        for(let t of e.changedTouches) {
            if(t.identifier === joyData.id) {
                let dx = t.clientX - joyData.centerX, dy = t.clientY - joyData.centerY;
                let dist = Math.min(Math.sqrt(dx*dx + dy*dy), 50);
                let angle = Math.atan2(dy, dx);
                stick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
                moveDir.s = dx / 50; moveDir.f = -dy / 50; 
            }
            if(t.identifier === lookData.id) {
                camera.rotation.y -= (t.clientX - lookData.lastX) * stats.sens;
                camera.rotation.x -= (t.clientY - lookData.lastY) * stats.sens;
                camera.rotation.x = Math.max(-1.4, Math.min(1.4, camera.rotation.x));
                lookData.lastX = t.clientX; lookData.lastY = t.clientY;
            }
        }
    };

    window.ontouchend = e => {
        for(let t of e.changedTouches) {
            if(t.identifier === joyData.id) { joyData.id = null; moveDir = {f:0, s:0}; stick.style.transform = `translate(0,0)`; }
            if(t.identifier === lookData.id) lookData.id = null;
        }
    };

    document.getElementById('sprint-btn').ontouchstart = e => { e.preventDefault(); stats.isSprinting = true; };
    document.getElementById('sprint-btn').ontouchend = e => { e.preventDefault(); stats.isSprinting = false; };
    
    flashBtn.ontouchstart = e => {
        e.preventDefault();
        if(stats.battery > 0) {
            stats.lightOn = !stats.lightOn;
            flashlight.visible = nearLight.visible = stats.lightOn;
            playClick();
            flashBtn.style.background = stats.lightOn ? "rgba(0,200,255,0.4)" : "rgba(0,0,0,0.4)";
        }
    };
}

function checkCollision(pos) {
    for(let t of treePositions) {
        let dx = pos.x - t.x, dz = pos.z - t.z;
        if((dx*dx + dz*dz) < 1.3) return true;
    }
    return false;
}

function interact(x, y) {
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1);
    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(notes);
    if(hits.length > 0 && hits[0].distance < 6) {
        let obj = hits[0].object;
        if(obj.visible) {
            obj.visible = false; stats.notes++;
            document.getElementById('notes-text').innerText = `ЗАПИСКИ: ${stats.notes} / 10`;
            playPaper();
            let sIdx = randomScreamerIndices.indexOf(obj.userData.id);
            if(sIdx !== -1) triggerScreamer(`scary${sIdx+1}.png`, false);
        }
    }
}

function triggerScreamer(img, kill) {
    const s = document.getElementById('screamer');
    s.style.backgroundImage = `url('${img}')`; s.style.display = 'block';
    const scream = kill ? sndDeathScream : sndNoteScream;
    scream.volume = 1; scream.currentTime = 0; scream.play().catch(()=>{});
    setTimeout(() => { s.style.display = 'none'; if(kill) location.reload(); }, 1200);
}

function updateMonster(dt) {
    if(stats.notes < 3) return;
    monster.visible = true;
    const distSq = camera.position.distanceToSquared(monster.position);
    
    // Дыхание
    let dist = Math.sqrt(distSq);
    let vol = Math.max(0, 1 - (dist / 45));
    sndBreath.volume = vol * masterGain.gain.value;
    if(sndBreath.paused) sndBreath.play().catch(()=>{});

    if(monsterState === 'idle') monsterState = 'stalk';

    // РЕЖИМ СЛЕЖКИ: Поглядывает издалека (15-25 метров)
    if(monsterState === 'stalk') {
        if(Math.random() < 0.007) {
            let a = camera.rotation.y + Math.PI + (Math.random()-0.5)*2.5;
            let spawnDist = 16 + Math.random() * 8; // ДИСТАНЦИЯ СЛЕЖКИ
            monster.position.set(camera.position.x + Math.sin(a)*spawnDist, 0, camera.position.z + Math.cos(a)*spawnDist);
            monster.lookAt(camera.position.x, 0, camera.position.z);
        }
    }

    if(stats.notes >= 5 && monsterState === 'stalk') { monsterState = 'attack5'; monsterTime = 30; document.getElementById('blood').style.display = 'block'; }
    if(stats.notes >= 9 && monsterState !== 'attack9') { monsterState = 'attack9'; monsterTime = 60; document.getElementById('blood').style.display = 'block'; }
    
    if(monsterState.includes('attack')) {
        monsterTime -= dt;
        let speed = 0.16;
        let dir = new THREE.Vector3().subVectors(camera.position, monster.position);
        dir.y = 0; dir.normalize();
        monster.position.add(dir.multiplyScalar(speed));
        monster.lookAt(camera.position.x, 0, camera.position.z);
        if(distSq < 3.5) triggerScreamer("death.png", true);
        if(monsterTime <= 0) { monsterState = 'stalk'; document.getElementById('blood').style.display = 'none'; }
    }
    
    if(distSq < 50) { // Дрожь камеры
        camera.position.x += (Math.random()-0.5)*0.08; camera.position.y += (Math.random()-0.5)*0.08;
    }
    if(distSq < 3.0) triggerScreamer("death.png", true);
}

function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1);
    if(stats.isSprinting && (moveDir.f !== 0 || moveDir.s !== 0) && stats.stamina > 0) stats.stamina -= 30 * dt;
    else stats.stamina = Math.min(100, stats.stamina + 15 * dt);
    document.getElementById('stamina-fill').style.width = stats.stamina + '%';

    if(stats.lightOn) {
        stats.battery -= 1.67 * dt; // 60с
        if(stats.battery <= 0) { stats.battery = 0; stats.lightOn = false; flashlight.visible = nearLight.visible = false; }
    } else stats.battery = Math.min(100, stats.battery + 6.67 * dt); // 15с
    document.getElementById('battery-fill').style.width = stats.battery + '%';

    let speed = (stats.isSprinting && stats.stamina > 5) ? 0.32 : 0.15;
    let oldPos = camera.position.clone();
    camera.translateZ(-moveDir.f * speed); camera.translateX(moveDir.s * speed);
    camera.position.y = 1.8;
    if(checkCollision(camera.position)) camera.position.copy(oldPos);

    updateMonster(dt);
    renderer.render(scene, camera);
}

document.getElementById('start-btn').onclick = () => {
    document.documentElement.requestFullscreen().catch(()=>{});
    stats.sens = document.getElementById('sens').value * 0.000045;
    masterGain.gain.value = document.getElementById('vol').value / 100;
    audioCtx.resume();
    document.getElementById('menu').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    init();
};

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>